!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ALU_CONTROL	util.h	/^  short ALU_CONTROL;$/;"	m	struct:EX_control_signals
ALU_OP	util.h	/^  short ALU_OP;$/;"	m	struct:EX_control_signals
ALU_SRC	util.h	/^  bool ALU_SRC;$/;"	m	struct:EX_control_signals
BASE	run.h	48;"	d
BRANCH	util.h	/^  bool BRANCH;$/;"	m	struct:EX_control_signals
BRANCH_INST	run.h	89;"	d
BRANCH_PC	util.h	/^	uint32_t BRANCH_PC;$/;"	m	struct:CPU_State_Struct
BR_BIT	util.c	/^int BR_BIT;$/;"	v
BYTES_PER_WORD	util.h	29;"	d
CC	run.h	58;"	d
COND	run.h	55;"	d
COND_EQ	run.h	78;"	d
COND_IN	run.h	80;"	d
COND_LT	run.h	79;"	d
COND_UN	run.h	77;"	d
CPU_State	util.h	/^} CPU_State;$/;"	t	typeref:struct:CPU_State_Struct
CPU_State_Struct	util.h	/^typedef struct CPU_State_Struct {$/;"	s
CURRENT_STATE	util.c	/^CPU_State CURRENT_STATE;$/;"	v
CYCLE_COUNT	util.c	/^uint64_t CYCLE_COUNT;$/;"	v
Cache	cache.h	/^uint32_t ***Cache; \/\/ data cache storing data [set][way][byte]$/;"	v
ENCODING	run.h	65;"	d
EXPR	run.h	68;"	d
EX_CONTROL	util.h	/^	struct EX_control_signals EX_CONTROL;$/;"	m	struct:ID_EX_PIPELINE	typeref:struct:ID_EX_PIPELINE::EX_control_signals
EX_MEM_ALU_IN_2	util.h	/^  uint32_t EX_MEM_ALU_IN_2; \/\/ sw : write data; create at EX$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_ALU_OUT	util.h	/^	uint32_t EX_MEM_ALU_OUT; \/\/ create at EX$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_BR_TAKE	util.h	/^	uint32_t EX_MEM_BR_TAKE; \/\/ create at EX$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_BR_TARGET	util.h	/^	uint32_t EX_MEM_BR_TARGET; \/\/ create at EX$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_DEST	util.h	/^	unsigned char EX_MEM_DEST; \/\/ from past & pass to next$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_FORWARD_REG	util.h	/^	unsigned char EX_MEM_FORWARD_REG;$/;"	m	struct:CPU_State_Struct
EX_MEM_FORWARD_VALUE	util.h	/^	uint32_t EX_MEM_FORWARD_VALUE;$/;"	m	struct:CPU_State_Struct
EX_MEM_NPC	util.h	/^	uint32_t EX_MEM_NPC; \/\/ from past & pass to next$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_PIPELINE	util.h	/^struct EX_MEM_PIPELINE {$/;"	s
EX_MEM_RD	util.h	/^  unsigned char EX_MEM_RD; \/\/ from past& pass to next$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_W_VALUE	util.h	/^	uint32_t EX_MEM_W_VALUE; \/\/ ??$/;"	m	struct:EX_MEM_PIPELINE
EX_MEM_ZERO_OUT	util.h	/^	bool EX_MEM_ZERO_OUT; \/\/ alu output is equal to 0; create at EX$/;"	m	struct:EX_MEM_PIPELINE
EX_STAGE	util.h	34;"	d
EX_Stage	run.c	/^void EX_Stage() {$/;"	f
EX_control_signals	util.h	/^struct EX_control_signals {$/;"	s
FALSE	util.h	20;"	d
FD	run.h	39;"	d
FETCH_BIT	util.c	/^int FETCH_BIT;		\/* instruction fetch bit *\/$/;"	v
FORWARDING_BIT	util.c	/^int FORWARDING_BIT;$/;"	v
FS	run.h	33;"	d
FT	run.h	36;"	d
FUNC	run.h	21;"	d
IDISP	run.h	53;"	d
ID_EX_DEST	util.h	/^	unsigned char ID_EX_DEST;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_IMM	util.h	/^	short ID_EX_IMM;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_INST	util.h	/^	instruction * ID_EX_INST;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_NPC	util.h	/^	uint32_t ID_EX_NPC;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_PIPELINE	util.h	/^struct ID_EX_PIPELINE {$/;"	s
ID_EX_RD	util.h	/^  unsigned char ID_EX_RD;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_REG1	util.h	/^	uint32_t ID_EX_REG1;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_REG2	util.h	/^	uint32_t ID_EX_REG2;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_RS	util.h	/^  unsigned char ID_EX_RS;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_RT	util.h	/^  unsigned char ID_EX_RT;$/;"	m	struct:ID_EX_PIPELINE
ID_EX_num_stall	run.c	/^int ID_EX_num_stall = 0; \/\/ for hazard detection. load followed by alu instructions$/;"	v
ID_STAGE	util.h	33;"	d
ID_Stage	run.c	/^void ID_Stage() {$/;"	f
IF_ID_INST	util.h	/^	instruction * IF_ID_INST;$/;"	m	struct:IF_ID_PIPELINE
IF_ID_NPC	util.h	/^	uint32_t IF_ID_NPC;$/;"	m	struct:IF_ID_PIPELINE
IF_ID_PIPELINE	util.h	/^struct IF_ID_PIPELINE {$/;"	s
IF_ID_num_stall	run.c	/^int IF_ID_num_stall = 0; \/\/ for jump instructions and branching$/;"	v
IF_PC	util.h	/^	uint32_t IF_PC;$/;"	m	struct:CPU_State_Struct
IF_STAGE	util.h	32;"	d
IF_Stage	run.c	/^void IF_Stage() {$/;"	f
IMM	run.h	45;"	d
IMM_MAX	run.h	84;"	d
IMM_MIN	run.h	83;"	d
INSTRUCTION_COUNT	util.c	/^int INSTRUCTION_COUNT;$/;"	v
INST_INFO	util.c	/^instruction *INST_INFO;$/;"	v
IOFFSET	run.h	51;"	d
JUMP_INST	run.h	98;"	d
JUMP_PC	util.h	/^	uint32_t JUMP_PC;$/;"	m	struct:CPU_State_Struct
L1	grading_input/str_cpy.s	/^L1:	lw	$4,	0($1)$/;"	l
LOAD_INST	run.h	103;"	d
LOAD_INST_BASE	run.h	108;"	d
MAX_INSTRUCTION_NUM	util.c	/^uint64_t MAX_INSTRUCTION_NUM;$/;"	v
MEM_CONTROL	util.h	/^	struct MEM_control_signals MEM_CONTROL;$/;"	m	struct:EX_MEM_PIPELINE	typeref:struct:EX_MEM_PIPELINE::MEM_control_signals
MEM_CONTROL	util.h	/^	struct MEM_control_signals MEM_CONTROL;$/;"	m	struct:ID_EX_PIPELINE	typeref:struct:ID_EX_PIPELINE::MEM_control_signals
MEM_DATA_SIZE	util.h	27;"	d
MEM_DATA_START	util.h	26;"	d
MEM_NREGIONS	util.c	27;"	d	file:
MEM_READ	util.h	/^  bool MEM_READ;$/;"	m	struct:MEM_control_signals
MEM_REGIONS	util.c	/^mem_region_t MEM_REGIONS[] = {$/;"	v
MEM_STAGE	util.h	35;"	d
MEM_Stage	run.c	/^void MEM_Stage() {$/;"	f
MEM_TEXT_SIZE	util.h	25;"	d
MEM_TEXT_START	util.h	24;"	d
MEM_TO_REG	util.h	/^  bool MEM_TO_REG;$/;"	m	struct:WB_control_signals
MEM_WB_ALU_OUT	util.h	/^	uint32_t MEM_WB_ALU_OUT;$/;"	m	struct:MEM_WB_PIPELINE
MEM_WB_BR_TAKE	util.h	/^	uint32_t MEM_WB_BR_TAKE;$/;"	m	struct:MEM_WB_PIPELINE
MEM_WB_DEST	util.h	/^	unsigned char MEM_WB_DEST;$/;"	m	struct:MEM_WB_PIPELINE
MEM_WB_FORWARD_REG	util.h	/^	unsigned char MEM_WB_FORWARD_REG;$/;"	m	struct:CPU_State_Struct
MEM_WB_FORWARD_VALUE	util.h	/^	uint32_t MEM_WB_FORWARD_VALUE;$/;"	m	struct:CPU_State_Struct
MEM_WB_MEM_OUT	util.h	/^	uint32_t MEM_WB_MEM_OUT;$/;"	m	struct:MEM_WB_PIPELINE
MEM_WB_NPC	util.h	/^	uint32_t MEM_WB_NPC;$/;"	m	struct:MEM_WB_PIPELINE
MEM_WB_PIPELINE	util.h	/^struct MEM_WB_PIPELINE {$/;"	s
MEM_WB_RD	util.h	/^  	unsigned char MEM_WB_RD;$/;"	m	struct:MEM_WB_PIPELINE
MEM_WRITE	util.h	/^  bool MEM_WRITE;$/;"	m	struct:MEM_control_signals
MEM_control_signals	util.h	/^struct MEM_control_signals {$/;"	s
MIPS_REGS	util.h	28;"	d
ND	run.h	59;"	d
NUM_INST	util.c	/^int NUM_INST;$/;"	v
Next_PC	run.c	/^uint32_t Next_PC = 0;$/;"	v
OPCODE	run.h	18;"	d
PC	util.h	/^	uint32_t PC;			\/* program counter for the IF stage*\/$/;"	m	struct:CPU_State_Struct
PC_SRC	util.h	/^  bool PC_SRC;$/;"	m	struct:MEM_control_signals
PIPE	util.h	/^	uint32_t PIPE[PIPE_STAGE];	\/* PC being executed at each stage*\/$/;"	m	struct:CPU_State_Struct
PIPE_STAGE	util.h	30;"	d
PIPE_STALL	util.h	/^	uint32_t PIPE_STALL[PIPE_STAGE];$/;"	m	struct:CPU_State_Struct
RD	run.h	30;"	d
REGS	util.h	/^	uint32_t REGS[MIPS_REGS];	\/* register file *\/$/;"	m	struct:CPU_State_Struct
REGS_LOCK	util.h	/^	uint32_t REGS_LOCK[MIPS_REGS];	\/* register lock to support stalls $/;"	m	struct:CPU_State_Struct
REG_DST	util.h	/^  bool REG_DST;$/;"	m	struct:EX_control_signals
REG_WRITE	util.h	/^  bool REG_WRITE;$/;"	m	struct:WB_control_signals
RS	run.h	24;"	d
RT	run.h	27;"	d
RUN_BIT	util.c	/^int RUN_BIT;		\/* run bit *\/$/;"	v
SET_BASE	run.h	49;"	d
SET_COND	run.h	56;"	d
SET_ENCODING	run.h	66;"	d
SET_EXPR	run.h	69;"	d
SET_FD	run.h	40;"	d
SET_FS	run.h	34;"	d
SET_FT	run.h	37;"	d
SET_FUNC	run.h	22;"	d
SET_IMM	run.h	46;"	d
SET_IOFFSET	run.h	52;"	d
SET_OPCODE	run.h	19;"	d
SET_RD	run.h	31;"	d
SET_RS	run.h	25;"	d
SET_RT	run.h	28;"	d
SET_SHAMT	run.h	43;"	d
SET_SOURCE	run.h	72;"	d
SET_TARGET	run.h	63;"	d
SHAMT	run.h	42;"	d
SIGN_EX	run.h	75;"	d
SOURCE	run.h	71;"	d
TARGET	run.h	62;"	d
TF	run.h	60;"	d
TRUE	util.h	21;"	d
UIMM_MAX	run.h	87;"	d
UIMM_MIN	run.h	86;"	d
WB_CONTROL	util.h	/^	struct WB_control_signals WB_CONTROL;$/;"	m	struct:EX_MEM_PIPELINE	typeref:struct:EX_MEM_PIPELINE::WB_control_signals
WB_CONTROL	util.h	/^	struct WB_control_signals WB_CONTROL;$/;"	m	struct:ID_EX_PIPELINE	typeref:struct:ID_EX_PIPELINE::WB_control_signals
WB_CONTROL	util.h	/^	struct WB_control_signals WB_CONTROL;$/;"	m	struct:MEM_WB_PIPELINE	typeref:struct:MEM_WB_PIPELINE::WB_control_signals
WB_STAGE	util.h	36;"	d
WB_Stage	run.c	/^void WB_Stage() {$/;"	f
WB_control_signals	util.h	/^struct WB_control_signals {$/;"	s
_PARSE_H_	parse.h	16;"	d
_RUN_H_	run.h	12;"	d
_UTIL_H_	util.h	11;"	d
alu_out_zero	run.c	/^bool alu_out_zero = 0;$/;"	v
branchPredictionFailed	run.c	/^bool branchPredictionFailed = 0;$/;"	v
cdump	util.c	/^void cdump(int capacity, int assoc, int blocksize){$/;"	f
cycle	util.c	/^void cycle(){$/;"	f
cycle_count	run.c	/^int cycle_count = 0;$/;"	v
darray	grading_input/str_cpy.s	/^darray:	.word	0x00000000$/;"	l
data1	grading_input/leaf_example.s	/^data1:	.word	1$/;"	l
data1	grading_input/various_inst.s	/^data1:	.word	1111$/;"	l
data2	grading_input/leaf_example.s	/^data2:	.word	2$/;"	l
data2	grading_input/various_inst.s	/^data2:	.word	0x2222$/;"	l
data3	grading_input/leaf_example.s	/^data3:	.word	3$/;"	l
data4	grading_input/leaf_example.s	/^data4:	.word	4$/;"	l
data_size	parse.c	/^int data_size;$/;"	v
dstmat	grading_input/trans_mat.s	/^dstmat:	.word	0$/;"	l
fill_pipeline	run.c	/^int fill_pipeline = 0;$/;"	v
finished	run.c	/^bool finished = 0;$/;"	v
fix_PC	run.c	/^bool fix_PC = 0; \/\/ To set PC value when instructions are all finished$/;"	v
flush_EX_MEM	run.c	/^void flush_EX_MEM() {$/;"	f
flush_ID_EX	run.c	/^void flush_ID_EX(){$/;"	f
flush_IF_ID	run.c	/^void flush_IF_ID(){$/;"	f
fromBinary	util.c	/^int fromBinary(const char *s){$/;"	f
func_code	util.h	/^    short func_code;$/;"	m	struct:inst_s
get_inst_info	run.c	/^instruction* get_inst_info(uint32_t pc) { $/;"	f
get_instr_type	run.c	/^short get_instr_type(short op) {$/;"	f
go	util.c	/^void go() {$/;"	f
hazard_detected	run.c	/^bool hazard_detected = 0;$/;"	v
imm	util.h	/^	        short imm;$/;"	m	union:inst_s::__anon1::__anon2::__anon3
init_inst_info	util.c	/^void init_inst_info()$/;"	f
init_memory	util.c	/^void init_memory() {$/;"	f
initialize	cs311.c	/^void initialize(char *program_filename) { $/;"	f
inner	grading_input/trans_mat.s	/^inner:	$/;"	l
inst_s	util.h	/^typedef struct inst_s {$/;"	s
instruction	util.h	/^typedef struct inst_s instruction;$/;"	t	typeref:struct:inst_s
instruction	util.h	/^} instruction;$/;"	t	typeref:struct:inst_s
jumpInstr	run.c	/^bool jumpInstr = 0;$/;"	v
jump_IF_ID_num_stall	run.c	/^int jump_IF_ID_num_stall = 0;$/;"	v
jumpandlink	run.c	/^bool jumpandlink = 0;$/;"	v
jumpandreturn	run.c	/^bool jumpandreturn = 0;$/;"	v
last_PC	run.c	/^uint32_t last_PC = 0;$/;"	v
load_program	cs311.c	/^void load_program(char *program_filename) {                   $/;"	f
loop	grading_input/add_vec.s	/^loop:	$/;"	l
main	cs311.c	/^int main(int argc, char *argv[]) {                              $/;"	f
main	grading_input/add_vec.s	/^main:$/;"	l
main	grading_input/leaf_example.s	/^main:$/;"	l
main	grading_input/str_cpy.s	/^main:$/;"	l
main	grading_input/trans_mat.s	/^main:$/;"	l
main	grading_input/various_inst.s	/^main:$/;"	l
mdump	util.c	/^void mdump(int start, int stop) {$/;"	f
mem	util.h	/^    uint8_t *mem;$/;"	m	struct:__anon5
mem_read_32	util.c	/^uint32_t mem_read_32(uint32_t address){$/;"	f
mem_read_block	util.c	/^void mem_read_block(uint32_t address, uint32_t* block){$/;"	f
mem_region_t	util.h	/^} mem_region_t;$/;"	t	typeref:struct:__anon5
mem_write_32	util.c	/^void mem_write_32(uint32_t address, uint32_t value){$/;"	f
mem_write_block	util.c	/^void mem_write_block(uint32_t address, uint32_t *block) {$/;"	f
miss_penalty	cache.h	/^int miss_penalty; \/\/ number of cycles to stall when a cache miss occurs$/;"	v
new_EX_MEM_pipeline	util.h	/^	struct EX_MEM_PIPELINE new_EX_MEM_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::EX_MEM_PIPELINE
new_ID_EX_pipeline	util.h	/^	struct ID_EX_PIPELINE new_ID_EX_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::ID_EX_PIPELINE
new_IF_ID_pipeline	util.h	/^	struct IF_ID_PIPELINE new_IF_ID_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::IF_ID_PIPELINE
new_MEM_WB_pipeline	util.h	/^	struct MEM_WB_PIPELINE new_MEM_WB_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::MEM_WB_PIPELINE
next_finished	run.c	/^bool next_finished = 0;$/;"	v
opcode	util.h	/^    short opcode;$/;"	m	struct:inst_s
out	grading_input/str_cpy.s	/^out:	$/;"	l
outer1	grading_input/trans_mat.s	/^outer1:	$/;"	l
outer2	grading_input/trans_mat.s	/^outer2:$/;"	l
parse_control_signals	run.c	/^void parse_control_signals(instruction * instr) {$/;"	f
parsing_data	parse.c	/^void parsing_data(const char *buffer, const int index)$/;"	f
parsing_instr	parse.c	/^instruction parsing_instr(const char *buffer, const int index)$/;"	f
past_EX_MEM_pipeline	util.h	/^	struct EX_MEM_PIPELINE past_EX_MEM_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::EX_MEM_PIPELINE
past_ID_EX_pipeline	util.h	/^	struct ID_EX_PIPELINE past_ID_EX_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::ID_EX_PIPELINE
past_IF_ID_pipeline	util.h	/^	struct IF_ID_PIPELINE past_IF_ID_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::IF_ID_PIPELINE
past_MEM_WB_pipeline	util.h	/^	struct MEM_WB_PIPELINE past_MEM_WB_pipeline;$/;"	m	struct:CPU_State_Struct	typeref:struct:CPU_State_Struct::MEM_WB_PIPELINE
pdump	util.c	/^void pdump() {$/;"	f
print_parse_result	parse.c	/^void print_parse_result()$/;"	f
process_instruction	run.c	/^void process_instruction(){$/;"	f
r	util.h	/^		} r;$/;"	m	union:inst_s::__anon1::__anon2::__anon3	typeref:struct:inst_s::__anon1::__anon2::__anon3::__anon4
r_i	util.h	/^	    } r_i;$/;"	m	struct:inst_s::__anon1::__anon2	typeref:union:inst_s::__anon1::__anon2::__anon3
r_i	util.h	/^	} r_i;$/;"	m	union:inst_s::__anon1	typeref:struct:inst_s::__anon1::__anon2
r_t	util.h	/^    } r_t;$/;"	m	struct:inst_s	typeref:union:inst_s::__anon1
rd	util.h	/^		    unsigned char rd;$/;"	m	struct:inst_s::__anon1::__anon2::__anon3::__anon4
rdump	util.c	/^void rdump() {$/;"	f
result	grading_input/add_vec.s	/^result:	.word	0$/;"	l
rs	util.h	/^	    unsigned char rs;$/;"	m	struct:inst_s::__anon1::__anon2
rt	util.h	/^	    unsigned char rt;$/;"	m	struct:inst_s::__anon1::__anon2
run	util.c	/^void run() {$/;"	f
sarray	grading_input/str_cpy.s	/^sarray:	.word	0x12345678$/;"	l
setCacheMissPenalty	cache.c	/^void setCacheMissPenalty(int penalty_cycles)$/;"	f
setupCache	cache.c	/^void setupCache(int capacity, int num_way, int block_size)$/;"	f
shamt	util.h	/^		    unsigned char shamt;$/;"	m	struct:inst_s::__anon1::__anon2::__anon3::__anon4
size	util.h	/^    uint32_t start, size;$/;"	m	struct:__anon5
srcmat	grading_input/trans_mat.s	/^srcmat:	.word	23$/;"	l
start	util.h	/^    uint32_t start, size;$/;"	m	struct:__anon5
str_split	util.c	/^char** str_split(char *a_str, const char a_delim){$/;"	f
target	util.h	/^        uint32_t target;$/;"	m	union:inst_s::__anon1
text_size	parse.c	/^int text_size;$/;"	v
text_size	run.c	/^int text_size;$/;"	v
value	util.h	/^    uint32_t value;$/;"	m	struct:inst_s
vec1	grading_input/add_vec.s	/^vec1:	.word	23$/;"	l
vec2	grading_input/add_vec.s	/^vec2:	.word	56$/;"	l
veclen	grading_input/add_vec.s	/^veclen:	.word	100$/;"	l
xdump	util.c	/^void xdump(int set, int way, int blocksize, uint32_t*** cache)$/;"	f
